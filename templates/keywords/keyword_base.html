{% extends 'base.html' %}
{% load staticfiles %}

{% block title %}Keywords{% endblock title %}

{% block content %}

<div class='container'>

  <h1>Keywords</h1>
  <p>
    Warning: if there is a dataset with out any associated keywords, it will not
    be searchable with this feature
  </p>

  <input id='keyword_query_input' type='text' placeholder='search'/>
  <!-- <input id='keyword_query_button' type='submit' /> -->
  <div id='keyword_list_div'></div>
  <div id='keyword_datasets'></div> <!-- should this just be keyword_datasets -->

</div>
<!-- this will be put into it's own js file -->
<script>

/*
The Goal: from a searchable list that does not reload the entire html document (via ajax)
pull in and display a list of keywords. Then make each of those keywords pull in and
display a list of associated datasets via ajax. This requires three separate views, the
first to act as the base view, where the search bar, container divs, and the
javascript will be loaded from. The next to be the list of keywords, and the next to be
the list of datasets. The datasets displayed will be dependent on the selected keyword.
If no keywords are selected then all datasets (actually the first 20 or something) will
be displayed.

Ideally as the keywords are whittled down by the search, the datasets will be
refined. However, instead of that I think that I will have to make the the datasets view
take only a single arguement to start with.

1) define container divs and search bar
  keyword list div
  dataset list div
  keyword search bar

2) define function that makes calls to the separate views (ajax)

3) set up the views correctly
  
*/

const keywordListDiv = document.getElementById('keyword_list_div')
const keywordListUrl = '/keywords/list'
const keywordQueryInput = document.getElementById('keyword_query_input')
const keywordDatasets = document.getElementById('keyword_datasets')

// the XMLHttpRequest function to get the view
const getPage = ( (url, func, target) => {
  const xhr = new XMLHttpRequest()
  xhr.open('GET', url, true)
  xhr.onload = () => {
    xhr.readyState === 4 && xhr.status === 200
      ? func(xhr.responseText, target)
      : console.log(xhr.statusText)
  }
  xhr.onerror = () => console.log('error')
  xhr.send()
})

// get the elements in the template that are in the div, and
// add event listeners to them that call their pages

// I don't like this code block
// this isn't working
/*
const getLinks = () => {
  const keywordLinks = document.getElementsByName('keyword_link')
  const links = []
  keywordLinks.forEach(link => {
    console.log(link.id)
    link.addEventListener('click', () => {
      getPage(link.id, dataToDiv, keywordDatasets) 
    })
  })

//  const refs = keywordLinks.map(link => {
//    console.log(link)
//    link.id
//  })
//  return refs

}


// data to div with links function
const dataToDivWithLinks = (data, div) => {
  getLinks(data)
  div.innerHTML = data
}
*/
// data to div with links function
const dataToDiv= (data, div) => {
  div.innerHTML = data
}



// add event listener to input
keywordQueryInput.addEventListener('input', () => {
  const val = keywordQueryInput.value
  const queryUrl = keywordListUrl + '?q=' + val
  getPage(queryUrl, dataToDiv, keywordListDiv)
})

getPage(keywordListUrl, dataToDiv, keywordListDiv)


</script>
{% endblock content %}
